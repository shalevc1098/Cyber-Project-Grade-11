#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 6.0.1
#  in conjunction with Tcl version 8.6
#    Mar 21, 2021 03:14:50 PM +0200  platform: Windows NT

import sys
import socket
import threading
import importlib
#sys.path.insert(0, 'C:/Users/Shalev/Desktop/תיקיות/Python Project/GUIS/games/fourinarow/game')
from GUIS.games.fourinarow.game import fourinarow
import queue

messages = queue.Queue()
fourinarow_queue = {}

try:
    import Tkinter as tk
    import Tkinter.messagebox
except ImportError:
    import tkinter as tk
    import tkinter.messagebox

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

import fourinarow_queue_support

running = True
canclose = False
invited = False
who_invited = ""
listener_stopped = True

def get_can_close():
    global canclose
    return canclose

def set_can_close(val):
    global canclose
    canclose = val

def loop(my_socket):
    global running
    global invited
    global who_invited
    global listener_stopped
    while running:
        try:
            response = my_socket.recv(1024).decode()
            if listener_stopped:
                messages.put(response)
            args = response.split(",")
            if args[0] == "start_fourinarow":
                running = False
            if not listener_stopped:
                if args[0] == "new_invitation":
                    name = args[1]
                    if who_invited != "" and who_invited != name:
                        my_socket.send(f"fourinarow_queue,error_box_to_another_client,{name},An error occurred!,There was an error. Please try again later.,reset_button_state".encode())
                    if not invited and who_invited == name:
                        invited = True
                elif args[0] == "cancel_invite":
                    #fourinarow_queue,cancel_invite,username,target -> Server recive
                    #cancel_invite,name -> Server response
                    name = args[1]
                    if invited and who_invited == name:
                        invited = False
        except:
            running = False

def new_invitation(my_socket, name, target):
    global invited
    global who_invited
    global listener_stopped
    answer = tk.messagebox.askyesnocancel(f"You received new invite from {name}!", "Do you want to accept?")
    if answer:
        if invited and who_invited == name:
            my_socket.send(f"fourinarow_queue,start_game,{name},{target}".encode())
            my_socket.send("fourinarow_queue,reset_selection".encode())
        elif not invited and who_invited == name:
            tk.messagebox.showinfo("The inviter canceled the invite!", f"You cant play with {name} because he canceled the invite.")
    else:
        if invited and who_invited == name:
            my_socket.send(f"fourinarow_queue,info_box_to_another_client,{name},{target} decline your Invite!,And for that reason you can't play with him.,reset_button_state".encode())
    invited = False
    who_invited = ""
    listener_stopped = True
    

def client_handler(my_socket, top, label, username, users_combobox, invite_button, geometry):
    global running
    global invited
    global who_invited
    global listener_stopped
    while running:
        top.update()
        while not messages.empty():
            message = messages.get()
            print(message)
            args = message.split(",")
            if args[0] == "addtoqueue":
               label.configure(text=args[1])
               my_socket.send(f"fourinarow_queue,append,{username}".encode())
            elif args[0] == "removefromqueue":
                label.configure(text=args[1])
            elif args[0] == "start_fourinarow":
                game_id = int(args[1])
                player = int(args[2])
                my_socket.send(f"fourinarow_queue,deappend,{username}".encode())
                top.withdraw()
                running = False
                importlib.reload(fourinarow)
                fourinarow.start(game_id, player, my_socket, username, geometry)
            elif args[0] == "append":
                del args[0]
                for name in args:
                    if name not in users_combobox["values"]:
                        users_combobox["values"] = (*users_combobox["values"], name)
            elif args[0] == "deappend":
                name = args[1]
                if name in users_combobox["values"]:
                    temp_list = list(users_combobox["values"])
                    temp_list.remove(name)
                    users_combobox["values"] = tuple(temp_list)
            elif args[0] == "new_invitation":
                name = args[1]
                target = args[2]
                if not invited and who_invited == "": #לא מוזמן ושם ריק
                    my_socket.send(f"fourinarow_queue,info_box_to_another_client,{name},Invite Sent!,{target} has been successfully invited.".encode())
                    invited = True
                    who_invited = name
                    listener_stopped = False
                    #Make a thread that response to invited and who_invited changes
                    new_invitation(my_socket, name, target) #name -> who sent the invite, target -> who received the invite
                elif not invited and who_invited == name: #לא מוזמן ושם שווה למטרה
                    invited = True
                else:
                    my_socket.send(f"fourinarow_queue,error_box_to_another_client,{name},An error occurred!,There was an error. Please try again later.".encode())
            elif args[0] == "reset_selection":
                users_combobox.set("")
            elif args[0] == "info_box":
                title = args[1]
                description = args[2]
                if len(args) == 4:
                    cmd = args[3]
                    if cmd == "reset_button_state":
                        invite_button['text'] = "Invite"
                tk.messagebox.showinfo(title, description)
            elif args[0] == "error_box":
                title = args[1]
                description = args[2]
                if len(args) == 4:
                    cmd = args[3]
                    if cmd == "reset_button_state":
                        invite_button['text'] = "Invite"
                tk.messagebox.showerror(title, description)

def send_invite(top, my_socket, username, target, invite_button):
    global invited
    button_text = invite_button['text']
    if target == "":
        tk.messagebox.showwarning("Warning!", "You have to select username from the list in order to invite him.")
        return
    if button_text == "Invite":
        if not invited:
            my_socket.send(f"fourinarow_queue,invite,{username},{target}".encode())
            invite_button['text'] = "Cancel"
        else:
            tk.messagebox.showerror("An error occurred!", "There was an error. Please try again later.")
    elif button_text == "Cancel":
        my_socket.send(f"fourinarow_queue,cancel_invite,{username},{target}".encode())
        invite_button['text'] = "Invite"
    return

def on_closing(my_socket, root, username):
    global running, canclose
    canclose = True
    running = False
    my_socket.send(f"fourinarow_queue,removefromqueue,{username}".encode())
    my_socket.send(f"fourinarow_queue,deappend,{username}".encode())
    my_socket.shutdown(socket.SHUT_RDWR)
    my_socket.close()
    root.destroy()

def vp_start_gui(my_socket, username, geometry):
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    top = FourInARow_Queue (my_socket, username, geometry, root)
    fourinarow_queue_support.init(root, top)
    root.protocol("WM_DELETE_WINDOW", lambda: on_closing(my_socket, root, username))
    a = threading.Thread(target=loop, args=(my_socket,))
    a.start()
    client_handler(my_socket, root, top.get_top(), username, top.get_users_combobox(), top.get_invite_button(), geometry)

w = None
def create_FourInARow_Queue(rt, *args, **kwargs):
    '''Starting point when module is imported by another module.
       Correct form of call: 'create_FourInARow_Queue(root, *args, **kwargs)' .'''
    global w, w_win, root
    #rt = root
    root = rt
    w = tk.Toplevel (root)
    top = FourInARow_Queue (w)
    fourinarow_queue_support.init(w, top, *args, **kwargs)
    return (w, top)

def destroy_FourInARow_Queue():
    global w
    w.destroy()
    w = None

class FourInARow_Queue:
    def __init__(self, my_socket, username, geometry, top=None):
        self.my_socket = my_socket
        self.username = username
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9' # X11 color: 'gray85'
        _ana1color = '#d9d9d9' # X11 color: 'gray85'
        _ana2color = '#ececec' # Closest X11 color: 'gray92'

        top.geometry(geometry)
        top.minsize(120, 1)
        top.maxsize(1924, 1061)
        top.resizable(1,  1)
        top.title(f"FourInARow_Queue - {username}")
        top.configure(background="#d9d9d9")

        self.FourInARow_Queue = tk.Label(top)
        self.FourInARow_Queue.place(relx=0.433, rely=0.311, height=21, width=74)
        self.FourInARow_Queue.configure(background="#d9d9d9")
        self.FourInARow_Queue.configure(disabledforeground="#a3a3a3")
        self.FourInARow_Queue.configure(foreground="#000000")
        self.FourInARow_Queue.configure(text=f'''In Queue: 0''')

        self.FourInARow_Users_ComboBox = ttk.Combobox(top, state="readonly", width = 27, textvariable = tk.StringVar())
        #self.FourInARow_Users_ComboBox.place(relx=0.433, rely=0.361)
        self.FourInARow_Users_ComboBox.place(relx=0.433, rely=0.361, height=21, width=74)

        self.FourInARow_Invite_Button = tk.Button(top)
        self.FourInARow_Invite_Button.place(relx=0.433, rely=0.411, height=21, width=74)
        self.FourInARow_Invite_Button.configure(activebackground="#ececec")
        self.FourInARow_Invite_Button.configure(activeforeground="#000000")
        self.FourInARow_Invite_Button.configure(background="#d9d9d9")
        self.FourInARow_Invite_Button.configure(cursor="hand2")
        self.FourInARow_Invite_Button.configure(disabledforeground="#a3a3a3")
        self.FourInARow_Invite_Button.configure(foreground="#000000")
        self.FourInARow_Invite_Button.configure(highlightbackground="#d9d9d9")
        self.FourInARow_Invite_Button.configure(highlightcolor="black")
        self.FourInARow_Invite_Button.configure(pady="0")
        self.FourInARow_Invite_Button.configure(text='''Invite''')
        self.FourInARow_Invite_Button.configure(command=lambda: send_invite(top, self.my_socket, self.username, self.FourInARow_Users_ComboBox.get(), self.FourInARow_Invite_Button))

        my_socket.send(f"fourinarow_queue,addtoqueue,{username}".encode())

    def get_top(self):
        return self.FourInARow_Queue

    def get_users_combobox(self):
        return self.FourInARow_Users_ComboBox

    def get_invite_button(self):
        return self.FourInARow_Invite_Button

if __name__ == '__main__':
    vp_start_gui()

"""
if invited and who_invited == "":
    ----CLIENT_HANDLER----
    ----NEW_INVITATION----
    if not invited and who_invited == "":
        invited = True
        who_invited = name
        start thread to show yes no messagebox without blocking the client handler function
    elif not invited and who_invited == name:
        invited = True
    else:
        send back to the inviter an error message that indicates that the client who he invited is already invited by another client
    ----CANCEL_INVITE----
    if invited:
        invited = False
    ----THREAD----
    answer = show yes no messagebox
    if not invited and who_invited == name:
        who_invited == ""
        show an info messagebox that indicates that the inviter canceled the invite
    elif answer and invited and who_invited == name:
        send start game to the server in order to start new fourinarow game
    elif not answer and invited and who_invited == name:
        send an info message to the client who sent the invite that the client he sent the invite to declined it
    else:
        send an error message to the inviter that indicates that an error occurred
"""